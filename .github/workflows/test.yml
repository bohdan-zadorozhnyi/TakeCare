name: Docker Container Test

on:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]
  workflow_dispatch:

jobs:
  docker-test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
      
      - name: Create .env file
        run: |
          echo "# Django settings" > .env
          echo "DJANGO_SECRET_KEY=django-insecure-test-key-for-ci-cd" >> .env
          echo "DJANGO_DEBUG=True" >> .env
          echo "" >> .env
          echo "# Database configuration" >> .env
          echo "POSTGRES_DB=takecare" >> .env
          echo "POSTGRES_USER=postgres" >> .env
          echo "POSTGRES_PASSWORD=postgres" >> .env
          echo "POSTGRES_HOST=db" >> .env
          echo "POSTGRES_PORT=5432" >> .env
          echo "" >> .env
          echo "# Redis configuration" >> .env
          echo "REDIS_HOST=redis" >> .env
          echo "REDIS_PORT=6379" >> .env
          echo "" >> .env
          echo "# Superuser Settings" >> .env
          echo "DJANGO_SUPERUSER_EMAIL=admin@example.com" >> .env
          echo "DJANGO_SUPERUSER_PASSWORD=admin123" >> .env
          echo "" >> .env
          echo "# Application Settings" >> .env
          echo "ALLOWED_HOSTS=localhost,127.0.0.1" >> .env
          echo "TIME_ZONE=UTC" >> .env
          echo "" >> .env
          echo "# Development Settings" >> .env
          echo "PYTHONDONTWRITEBYTECODE=1" >> .env
          echo "PYTHONUNBUFFERED=1" >> .env
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1
      
      - name: Start Docker Compose and check if it builds successfully
        run: |
          docker compose build
          # Start the containers in detached mode
          docker compose up -d
          
          # Wait for the containers to initialize
          echo "Waiting for containers to start up..."
          sleep 30
          
          # Check if all containers are running
          CONTAINERS_RUNNING=$(docker compose ps -q | wc -l)
          echo "Number of running containers: $CONTAINERS_RUNNING"
          
          # Check if the web container is running and healthy
          WEB_STATUS=$(docker compose ps -q web | xargs docker inspect -f '{{.State.Status}}')
          echo "Web container status: $WEB_STATUS"
          
          # Try to access the web application (may need adjustment depending on how your app responds)
          echo "Testing web application response..."
          MAX_RETRIES=5
          RETRY_COUNT=0
          WEB_OK=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/ | grep -q '200\|302\|301\|401\|403'; then
              WEB_OK=true
              break
            fi
            echo "Waiting for web application to respond... (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)"
            RETRY_COUNT=$((RETRY_COUNT+1))
            sleep 10
          done
          
          # Print container logs for debugging
          echo "Web container logs:"
          docker compose logs web
          
          # Check if all tests passed
          if [ "$WEB_STATUS" = "running" ] && [ "$WEB_OK" = "true" ]; then
            echo "✅ TEST PASSED: Container is running successfully and web application responds!"
            docker compose down
            exit 0
          else
            echo "❌ TEST FAILED: Container did not start properly or web application did not respond"
            echo "Full container logs:"
            docker compose logs
            docker compose down
            exit 1
          fi